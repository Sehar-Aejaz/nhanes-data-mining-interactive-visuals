# -*- coding: utf-8 -*-
"""nhanes-data-mining-interactive-visuals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NICpdS-D3rpxO-jRBixQZ2YBGjDbbsow

## Abstract

I will merge datasets from the NHANES study, clean the data, and perform an in-depth analysis of various health metrics. Using the Bokeh package, I will create multiple interactive visualizations—such as scatter plots, histograms, and line graphs—to explore trends in BMI, blood pressure, cholesterol, and dietary intake across age, gender, and ethnicity. These visual tools will allow for detailed subgroup insights, such as gender differences in BMI and age-related changes in health metrics. A dynamic table will be created to provide an interactive way to filter and explore the data. The analysis will provide valuable insights into population health, with an emphasis on ethical considerations and potential data privacy issues associated with using sensitive health information.

## Loading the necessary libraries
"""

# Core libraries
import os
import numpy as np
import pandas as pd
import pyreadstat
from functools import reduce

# Bokeh visualization tools
from bokeh.io import output_notebook, show
from bokeh.plotting import figure
from bokeh.models import (
    ColumnDataSource, HoverTool, DataTable, TableColumn, NumberFormatter,
    LinearColorMapper, ColorBar, BasicTicker, PrintfTickFormatter,
    Whisker, Label, LassoSelectTool, Range1d, RangeSlider, Select
)
from bokeh.layouts import column, row, gridplot
from bokeh.palettes import Viridis256, Category10
from bokeh.transform import transform

# Panel for interactivity
import panel as pn

# Scikit-learn preprocessing
from sklearn.impute import SimpleImputer, KNNImputer
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import LocalOutlierFactor

"""## Loading the data

In this code, I load several NHANES `.xpt` data files using `pyreadstat` and store them as DataFrames in a dictionary. I then merge all the DataFrames on the `SEQN` column (a unique participant ID) using an outer join to create a comprehensive dataset. This merged DataFrame is saved as a CSV file for future use. After that, I import Bokeh tools for visualization, set it to display plots in the notebook, and load the merged CSV file into a DataFrame for analysis.

"""

# List of your files
file_paths = {
    "TCHOL": "TCHOL_J.xpt",
    "DR1TOT": "DR1TOT_J.xpt",
    "DEMO": "DEMO_J.xpt",
    "BPX": "BPX_J.xpt",
    "BMX": "BMX_J.xpt"
}

# Load each file into a DataFrame
dataframes = {}
for name, path in file_paths.items():
    df, meta = pyreadstat.read_xport(path)
    dataframes[name] = df
    print(f"Loaded {name}: {df.shape}")

# Merge on SEQN (common subject ID)
merged_df = reduce(lambda left, right: pd.merge(left, right, on="SEQN", how="outer"), dataframes.values())

# Save the merged DataFrame for later use
merged_df.to_csv("merged_nhanes_manual.csv", index=False)
print("Merged dataset saved as 'merged_nhanes_manual.csv'")

merged_df.shape

output_notebook()

# Load merged dataset
df = pd.read_csv("merged_nhanes_manual.csv")

"""## Selecting the columns important for useful analysis

Now I create a list of column names that I want to extract from the merged dataset. These columns include key demographic, body measurement, blood pressure, cholesterol, and dietary intake variables. I use this list to create a new DataFrame `df_selected` that contains only these selected columns. Then, I rename the columns to more human-readable names, like changing `"RIDAGEYR"` to `"Age"` and `"DR1TTFAT"` to `"Fat (g)"`, to make the dataset easier to understand and work with. After renaming, I set `"ID"` (formerly `"SEQN"`) as the index of the DataFrame. Finally, I identify which of the remaining columns are numeric by selecting only those with numeric data types, so I can use them for analysis or visualization later.

"""

cols = ["SEQN", "RIDAGEYR", "RIAGENDR", "RIDRETH3",  # DEMO
        "BMXBMI", "BMXWT",                           # BMX
        "BPXSY1", "BPXDI1",                          # BPX
        "LBXTC",                                     # TCHOL
        "DR1TKCAL", "DR1TPROT", "DR1TTFAT"]          # DR1TOT

df_selected = merged_df[cols]

# Rename the columns to human-readable names
df_selected = df_selected.rename(columns={
    "SEQN": "ID",
    "RIDAGEYR": "Age",
    "RIAGENDR": "Gender",
    "RIDRETH3": "RaceEthnicity",
    "BMXBMI": "BMI",
    "BMXWT": "Weight (kg)",
    "BPXSY1": "Systolic BP",
    "BPXDI1": "Diastolic BP",
    "LBXTC": "Cholesterol",
    "DR1TKCAL": "Calories",
    "DR1TPROT": "Protein (g)",
    "DR1TTFAT": "Fat (g)"
})

df_selected = df_selected.set_index("ID")
# Select numeric columns (ID is now index, so not included)
numeric_cols = df_selected.select_dtypes(include=np.number).columns

"""## Cleaning the data
### Data Statistics
In this section of the code, I begin by generating a basic summary of the selected dataset using `df_selected.describe().T`, which gives me key statistics (like mean, standard deviation, and quartiles) for each numeric column, transposed for easier reading. Then, I calculate the total number and percentage of missing values in each column. I do this by creating a DataFrame called `missing_info` that contains the missing value count and the percentage of missing data for each column, rounded to two decimal places.

"""

# Basic summary
df_selected.describe().T

"""The dataset shows a diverse population with an average age of 34, fairly balanced gender distribution, and representation across seven race/ethnicity groups. Health metrics like BMI (avg. \~26.6), weight (65 kg), and blood pressure (121/68 mmHg) fall within normal ranges but show wide variability. Cholesterol averages 180 mg/dL, while daily calorie, protein, and fat intake also vary greatly, with some extreme values suggesting possible outliers or data quality issues. Overall, the data reflects broad demographic and health diversity.

"""

# Total missing and percentage
missing_info = df_selected.isnull().sum().to_frame(name="Missing Count")
missing_info["% Missing"] = (df_selected.isnull().mean() * 100).round(2)
missing_info

"""These missing value statistics reveal that while demographic variables like Age, Gender, and RaceEthnicity are fully complete, several health and nutritional features have substantial missing data. Most notably, over 30% of Systolic and Diastolic BP values are missing, and Cholesterol is missing in over 27% of records. Nutritional intake variables like Calories, Protein, and Fat each have about 19% missingness, and BMI is missing in 13.5% of cases. This pattern suggests a need for data imputation or careful handling during analysis to avoid biased results or loss of statistical power.

---

### Data Visualisation
Next, I define two custom functions for visualization using Bokeh. The first function, `bokeh_histogram`, creates a histogram for any given numeric column by first computing its histogram values with NumPy and then plotting the bars using Bokeh’s `quad` glyph. The second function, `bokeh_boxplot`, builds a boxplot by calculating quartiles and identifying outliers using the interquartile range (IQR). It then visualizes the box, whiskers, median, and outliers in a compact vertical plot.
"""

def bokeh_histogram(df, column, bins=30):
    hist, edges = np.histogram(df[column].dropna(), bins=bins)
    p = figure(title=f"Histogram of {column}", width=400, height=300)
    p.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:],
           fill_color="navy", line_color="white", alpha=0.7)
    return p

def bokeh_boxplot(df, column):
    col_data = df[column].dropna()
    q1 = col_data.quantile(0.25)
    q2 = col_data.quantile(0.5)
    q3 = col_data.quantile(0.75)
    iqr = q3 - q1
    upper = q3 + 1.5 * iqr
    lower = q1 - 1.5 * iqr
    outliers = col_data[(col_data > upper) | (col_data < lower)]

    p = figure(title=f"Boxplot of {column}", width=400, height=300, y_range=(col_data.min(), col_data.max()))
    p.segment(x0=0.5, y0=lower, x1=0.5, y1=upper, line_width=2)
    p.vbar(x=0.5, width=0.2, bottom=q1, top=q3, fill_color="skyblue", line_color="black")
    p.rect(x=0.5, y=q2, width=0.2, height=0.01, fill_color="black")
    p.scatter(x=0.5, y=outliers, size=6, color="red", alpha=0.6)
    p.xaxis.visible = False
    return p

"""Before plotting, I remove demographic variables like `"Age"`, `"Gender"`, and `"RaceEthnicity"` from the list of columns I want to visualize, since the focus is on numeric health and nutrition variables. I then loop through the remaining numeric columns and display both a histogram and a boxplot for each one using Bokeh’s `show()` function, arranging them vertically for clear comparison. This helps me visually assess the distribution and identify potential outliers in each variable."""

#Drop demographic variables from visualization subset
excluded = ["Age", "Gender", "RaceEthnicity"]
plot_cols = [col for col in df_selected.select_dtypes(include=np.number).columns if col not in excluded]

numeric_cols = df_selected.select_dtypes(include=np.number).columns

for col in plot_cols:
    hist = bokeh_histogram(df_selected, col)
    box = bokeh_boxplot(df_selected, col)
    show(column(hist, box))

"""Most of the variable distributions are right-skewed, except for Diastolic BP, which appears more normally distributed starting around 20, though it includes some values near zero. Systolic BP shows multiple peaks, while both Weight and BMI exhibit bimodal distributions. Box plots indicate a significant presence of outliers across all variables. Given this, we will conduct more detailed outlier analysis for Weight, BMI, Systolic BP, and Diastolic BP. For the remaining skewed variables, we'll apply **median imputation**, as the median is a more robust measure than the mean in skewed distributions.

### Outliers Detection and Imputation
In this code, I use the Local Outlier Factor (LOF) algorithm to detect outliers in the columns `"BMI"`, `"Diastolic BP"`, `"Systolic BP"`, and `"Weight (kg)"`. I apply the LOF model to flag outliers, then visualize them using Bokeh scatter plots, where outliers are colored red and normal data points are colored blue.

Next, I clean the data by replacing zero values in `Diastolic BP` with `NaN`, then separate the columns into those that will be imputed and those that require robust handling. I use median imputation for non-robust columns, as this method is less sensitive to outliers. For the robust columns, I use KNN imputation to estimate missing values based on the relationships between data points. This method considers the similarity between observations and is more suited to preserving the structure of the data—particularly useful in cases where variables, such as Systolic BP, Weight, and BMI, show multimodal distributions. Because these variables exhibit multiple peaks, KNN imputation is preferred, as it can better capture the local patterns in the data compared to global methods like mean or median imputation.
"""

lof = LocalOutlierFactor(n_neighbors=20, contamination=0.01)

df_temp = df_selected[["BMI", "Diastolic BP", "Systolic BP", "Weight (kg)"]].dropna()

outlier_flags = lof.fit_predict(df_temp)

df_outlier = df_temp.copy()
df_outlier["Outlier_LOF"] = (outlier_flags == -1)

# Color based on outlier status
df_outlier["color"] = np.where(df_outlier["Outlier_LOF"], "red", "blue")

source = ColumnDataSource(df_outlier)

p = figure(title="LOF Outlier Detection: BMI vs Weight",
           x_axis_label="BMI", y_axis_label="Weight (kg)")

p.scatter(x="BMI", y="Weight (kg)", color="color", source=source, size=8, alpha=0.6)
show(p)

df_outlier["color"] = np.where(df_outlier["Outlier_LOF"], "red", "blue")

source = ColumnDataSource(df_outlier)

p = figure(title="LOF Outlier Detection: Systolic vs Diastolic",
           x_axis_label="Diastolic BP", y_axis_label="Systolic BP")

p.scatter(x="Diastolic BP", y="Systolic BP", color="color", source=source, size=8, alpha=0.6)
show(p)

# Copy DataFrame
df_clean = df_selected.copy()

# Replace 0s in Diastolic BP with NaN
df_clean["Diastolic BP"] = df_clean["Diastolic BP"].replace(0, np.nan)

# Separate columns for robust regression and imputation
robust_cols = ["BMI", "Systolic BP", "Diastolic BP", "Weight (kg)"]
excluded = ["Age", "Gender", "RaceEthnicity"]
impute_cols = [col for col in df_clean.select_dtypes(include=np.number).columns
               if col not in excluded and col not in robust_cols]

# Median Impute non-robust columns
imputer = SimpleImputer(strategy="median")
df_clean[impute_cols] = imputer.fit_transform(df_clean[impute_cols])

# Prepare the columns to impute (only selected columns)
knn_impute_cols = ["Weight (kg)", "BMI", "Systolic BP", "Diastolic BP"]

# Apply KNN Imputation
imputer = KNNImputer(n_neighbors=5)
df_clean[knn_impute_cols] = imputer.fit_transform(df_clean[knn_impute_cols])

# Verify the changes
df_clean.isnull().sum()  # This will show the number of missing values after imputation

"""After imputation, we have now obtained a cleaned dataset with outliers effectively managed and missing values imputed, ensuring a more accurate and reliable dataset for further analysis.

## Interactive Correlation Heatmap with Gender & Race Filters
In this code, I select a set of numeric columns (such as `"Age"`, `"BMI"`, `"Systolic BP"`, etc.) and compute their correlation matrix. I then create a heatmap using Bokeh, where each cell's color reflects the strength of the correlation between two variables, using the "Viridis256" color palette. A color bar and hover tooltips are added to show the exact correlation values.

To make the heatmap interactive, I use Panel widgets to filter the data by gender and race/ethnicity. The `update_plot` function dynamically updates the heatmap based on the user's selections from the dropdowns. The final layout combines the dropdowns, heatmap, and legends into an interactive dashboard, allowing users to explore the correlations based on their demographic choices.
"""

# Select numeric columns for correlation with updated names
num_cols = ['Age', 'BMI', 'Weight (kg)', 'Systolic BP', 'Diastolic BP', 'Cholesterol',
            'Calories', 'Protein (g)', 'Fat (g)']

pn.extension()

df = df_clean

# Color mapper for heatmap
color_mapper = LinearColorMapper(palette="Viridis256", low=-1, high=1)

def compute_corr_data(df_sub):
    corr = df_sub[num_cols].corr().round(2)
    corr_df = corr.stack().reset_index()
    corr_df.columns = ['x', 'y', 'value']
    return ColumnDataSource(corr_df)

def create_heatmap(source):
    p = figure(title="Correlation Heatmap",
               x_range=num_cols, y_range=list(reversed(num_cols)),
               width=650, height=650, tools="", toolbar_location=None)

    p.rect(x="x", y="y", width=1, height=1, source=source,
           fill_color=transform('value', color_mapper), line_color=None)

    color_bar = ColorBar(color_mapper=color_mapper, location=(0, 0),
                         ticker=BasicTicker(), formatter=PrintfTickFormatter(format="%.2f"))
    p.add_layout(color_bar, 'right')

    p.add_tools(HoverTool(tooltips=[
        ("X", "@x"), ("Y", "@y"), ("Corr", "@value")
    ]))


    return p

# Panel widgets
gender_select = pn.widgets.Select(name='Gender', options=['All'] + sorted(df['Gender'].unique()))
race_select = pn.widgets.Select(name='RaceEthnicity', options=['All'] + sorted(df['RaceEthnicity'].unique()))

# Gender and Race legend boxes
gender_info = "### Gender Codes\n- 1 = Male\n- 2 = Female"
race_info = "### Race Codes\n- 1 = Mexican American\n- 2 = Hispanic\n- 3 = White\n- 4 = Black\n- 6 = Asian\n- 7 = Multiracial/Other"

gender_panel = pn.pane.Markdown(gender_info, width=150)
race_panel = pn.pane.Markdown(race_info, width=150)


# Callback function to update plot
@pn.depends(gender=gender_select, race=race_select)
def update_plot(gender, race):
    df_sub = df.copy()
    if gender != 'All':
        df_sub = df_sub[df_sub['Gender'] == gender]
    if race != 'All':
        df_sub = df_sub[df_sub['RaceEthnicity'] == race]

    source = compute_corr_data(df_sub)
    return create_heatmap(source)

# Final layout: dropdowns + heatmap + legends
layout = pn.Column(
    pn.Row(gender_select, race_select),
    pn.Row(update_plot, pn.Column(gender_panel, race_panel))
)

layout.servable()

"""This heatmap provides a clear visual summary of how key health and dietary variables are interrelated, and how stable these relationships remain across gender and ethnicity. The analysis reveals that age is moderately associated with BMI, weight, and blood pressure, indicating that these health metrics tend to increase with age. BMI and weight are strongly correlated, and both show moderate links to blood pressure, highlighting the connection between body composition and cardiovascular health. Systolic and diastolic blood pressure are also closely related, as expected. In terms of diet, calorie intake is strongly correlated with both protein and fat intake, and those two nutrients also correlate well with each other, reflecting typical dietary patterns. Notably, cholesterol shows weak correlations with all other variables, suggesting it may be influenced by factors not captured in this dataset.

Importantly, the fact that these patterns remain consistent across gender (±0.03) and race (±0.05) implies that these relationships are broadly applicable across the population, supporting generalizability in health monitoring and intervention strategies.

## Interactive scatter plots
In this code, I’m building an interactive scatter plot using Bokeh and Panel to explore relationships between different variables in my dataset. I start by creating a `ColumnDataSource` from the dataframe, which allows me to link the data to visual elements dynamically. Then, I set up a scatter plot with tools like pan and zoom for easy navigation, and I add a hover tool so that when I move the mouse over points, I can see the corresponding gender, race, and age information.

Next, I create two dropdown menus to let users choose which variables to plot on the x- and y-axes. When a selection changes, a callback function updates the data in the plot to reflect the new choices. This lets me explore different variable relationships without needing to regenerate the plot from scratch.
"""

# Create ColumnDataSource
source = ColumnDataSource(df)

# Create a figure for the scatter plot
p = figure(title="Interactive Scatter Plot", tools="pan,box_zoom,reset", width=600, height=400)
scatter = p.scatter(x="x", y="y", source=source, size=8, color="blue", alpha=0.6)

# Add Hover tool
hover = HoverTool()
hover.tooltips = [("Gender", "@Gender"), ("Race", "@RaceEthnicity"), ("Age", "@Age")]
p.add_tools(hover)

# Create dropdown widgets for selecting the x and y variables
x_select = Select(title="X-Axis", value="BMI", options=list(df.columns))
y_select = Select(title="Y-Axis", value="Cholesterol", options=list(df.columns))

# Update the scatter plot based on the selected x and y variables
def update_scatter(attr, old, new):
    # Get the selected x and y columns
    x_col = x_select.value
    y_col = y_select.value

    # Update the ColumnDataSource to reflect the new x and y columns
    source.data = {
        'x': df[x_col],
        'y': df[y_col],
        'Gender': df['Gender'],
        'RaceEthnicity': df['RaceEthnicity'],
        'Age': df['Age']
    }

# Attach the callback to the dropdown widgets
x_select.on_change('value', update_scatter)
y_select.on_change('value', update_scatter)

# Arrange the plot and widgets in a layout
layout = column(x_select, y_select, p)

# Display the interactive layout
pn.extension()
pn.panel(layout).servable()

"""From the scatter plots, I observe several patterns that align with the correlation heatmap results. Age shows a mild upward trend with both systolic and diastolic blood pressure. BMI has a strong positive correlation with weight, and also shows a subtle increasing trend with both blood pressure measures—evident in the cone-shaped distribution. Similarly, weight displays slight positive relationships with systolic and especially diastolic BP. Systolic and diastolic pressures themselves are clearly positively correlated. Cholesterol appears to have no consistent relationship with any variable, as its scatter plots are randomly distributed. Calorie intake shows strong positive trends with both fat and protein intake, which in turn are positively related to each other.

Overall, these scatter plots visually reinforce the correlation patterns seen in the heatmap.

## Age Distribution Histogram with Range Slider and Metric Overlay
In this code, I’m building an interactive plot to explore how a chosen health metric (like BMI, weight, or blood pressure) varies across different age groups. I start by creating two widgets: a range slider to filter the age range and a dropdown to select the metric to analyze.

I then set up a histogram to show the distribution of ages and overlay a line plot showing the average value of the selected metric in each age bin. The `update_plot` function filters the data based on the selected age range, calculates histogram counts, and computes the average metric value per bin. These are then updated in the plot through `ColumnDataSource`.

The widgets are connected to the update function, so the visualization responds in real time to user input. This allows for dynamic analysis of how health metrics change with age.
"""

# Widgets
age_slider = RangeSlider(start=min(df['Age']), end=max(df['Age']), value=(0, 80), step=1, title="Select Age Range")
metric_select = Select(title="Metric to Overlay", value="BMI", options=num_cols)

# DataSource and Plot
hist_source = ColumnDataSource(data=dict(top=[], left=[], right=[]))
metric_source = ColumnDataSource(data=dict(age_bin=[], avg_metric=[]))

p = figure(height=400, width=800, title="Age Distribution with Metric Overlay", tools="hover", tooltips=[
    ("Age Bin", "@left - @right"),
    ("Count", "@top"),
    ("Avg Metric", "@avg_metric{0.0}")
])

hist = p.quad(top='top', bottom=0, left='left', right='right', source=hist_source, fill_color='skyblue', line_color='black')
line = p.line(x='age_bin', y='avg_metric', source=metric_source, line_width=3, color="firebrick")

# Update Function
def update_plot(event=None):
    age_min, age_max = age_slider.value
    metric = metric_select.value
    filtered = df[(df["Age"] >= age_min) & (df["Age"] <= age_max)]

    hist_counts, edges = np.histogram(filtered["Age"], bins=15, range=(age_min, age_max))
    hist_source.data = dict(top=hist_counts, left=edges[:-1], right=edges[1:])

    # Bin by Age and compute average metric
    bins = pd.cut(filtered["Age"], bins=edges)
    grouped = filtered.groupby(bins)[metric].mean()
    bin_centers = [(edge.left + edge.right) / 2 for edge in grouped.index]

    metric_source.data = dict(age_bin=bin_centers, avg_metric=grouped.values)

# Initial plot
update_plot()

# Callbacks
age_slider.on_change("value", lambda attr, old, new: update_plot())
metric_select.on_change("value", lambda attr, old, new: update_plot())

layout = column(row(age_slider, metric_select), p)
pn.panel(layout).servable()

"""From the visualisation above, I observed that a significant portion of the participants were young children, with nearly 1,400 individuals under the age of 6. In the plot, the bins represent the number of people in each age group, while the line indicates the average value of a specific health metric within each group. For the adult age range (18–80), several trends emerged across various health metrics, highlighting patterns that may warrant further exploration:

* BMI peaked in the 42–48 age group with an average of 30.7, while it was lowest among young adults aged 18–22 at 27.4.

* Weight followed a similar trend, highest in the 38–43 group at 86.8 kg and lowest among seniors aged 75–80 at 74.1 kg.

* Systolic blood pressure increased steadily with age, rising from 113.7 mmHg (18–23) to 137.9 mmHg (75–80).

* Diastolic blood pressure rose until middle age and then declined. It peaked at 76.8 mmHg in the 47–51 age group and dropped to 65.5 mmHg for ages 18–23 and 67.4 mmHg for those 75–80.

* Cholesterol showed a similar pattern: increasing with age until 55–60 (199.7 mg/dL), then decreasing slightly to 178.7 mg/dL at 75–80; young adults (18–23) had the lowest average at 168.2 mg/dL.

* Calorie intake generally declined with age. Adults aged 30–35 consumed the most on average (2266.1 kcal/day), while those 75–80 consumed the least (1816.4 kcal/day).

* Protein intake peaked at 85 g/day in the 30–35 group, then tapered off to 67.2 g/day for seniors.

* Fat intake followed a similar curve, highest at 91.4 g/day (26–30) and lowest at 74.6 g/day (75–80).

These patterns highlight age-related shifts in body composition, cardiovascular indicators, and dietary habits, supporting insights found earlier in the correlation and scatter plots.

## Interactive Health Metric Trends by Age and Group

In this code, I build an interactive plot to visualize how a selected health metric (like BMI or weight) changes with age, grouped by either gender or race/ethnicity. I create two dropdown widgets to let users choose the grouping variable and the metric of interest.

I bin the age data into intervals and calculate the average metric for each group within each bin. Then, I plot these trends using colored lines and scatter points for each group, with hover tools showing the age, metric value, and group label.

The `update_plot()` function handles recalculating and redrawing the plot based on widget selections, and the layout is wrapped in a `Panel` app so it can be served interactively.
"""

# Widgets
group_select = pn.widgets.Select(name="Group by", value="Gender", options=["Gender", "RaceEthnicity"])
metric_select = pn.widgets.Select(name="Metric", value="BMI", options=num_cols)

# Shared Bokeh figure
p = figure(height=400, width=700, title="", tools="hover", tooltips=[
    ("Age", "@Age{0.0}"), ("Metric", "@value{0.0}"), ("Group", "@group")
])
source_dict = {}  # One source per group
renderers = []    # Line renderers to manage

# Initial plot creation
def update_plot(group_col, metric):
    p.title.text = f"{metric} by Age Grouped by {group_col}"
    p.renderers = []  # Clear previous lines

    df['AgeBin'] = pd.cut(df['Age'], bins=10)
    grouped = df.groupby([group_col, 'AgeBin']).agg({
        metric: 'mean',
        'Age': 'mean'
    }).reset_index()

    groups = grouped[group_col].unique()
    palette = Category10[10]
    colors = {g: palette[i % 10] for i, g in enumerate(groups)}

    for g in groups:
        sub = grouped[grouped[group_col] == g]
        sub = sub.sort_values('Age')
        source = ColumnDataSource({
            'Age': sub['Age'],
            'value': sub[metric],
            'group': [g]*len(sub)
        })
        p.line('Age', 'value', source=source, legend_label=str(g), line_width=2, color=colors[g])
        p.scatter('Age', 'value', source=source, size=6, color=colors[g])

    # Adjust y axis
    ymin = grouped[metric].min()
    ymax = grouped[metric].max()

    # Add buffer
    yrange = Range1d(start=ymin * 0.9, end=ymax * 1.1)
    p.y_range = yrange

    p.legend.title = group_col
    p.legend.location = "top_left"

# Panel callback
@pn.depends(group_select, metric_select)
def interactive_plot(group_by, metric):
    update_plot(group_by, metric)
    return p

# Layout
layout = pn.Column(
    pn.pane.Markdown("## Health Metric Trends by Age"),
    pn.Row(group_select, metric_select),
    interactive_plot
)

layout.servable()

"""- Gender Codes: 1 = Male, 2 = Female

- Race/Ethnicity Codes:
  - 1 = Mexican American, 2 = Hispanic, 3 = White, 4 = Black, 6 = Asian, 7 = Multiracial/Other

**Gender-Based Observations:**

From the line graphs, I observe that females tend to have a higher BMI than males across most age groups. The difference narrows around age 30, increases again through midlife, and slightly declines in older age. In contrast, males consistently have a higher weight than females, with the gap widening with age before leveling off.

For systolic blood pressure (Sys BP), males show higher values up to age 50, after which females overtake them through to old age. Diastolic blood pressure (Dias BP) is generally higher in males across nearly all age groups.

Cholesterol levels are nearly the same for both genders until about age 20. After that, males show higher levels up to around age 45, after which females show higher cholesterol into older age.

In terms of dietary intake, males consume more calories, protein, and fat than females at every age. The differences are particularly noticeable around ages 29 and 45.

**Ethnicity-Based Observations:**

When looking at BMI by ethnicity, Asians consistently have the lowest values, while Mexican Americans, Black individuals, and multiracial groups show the highest at various age ranges. The same trend is observed for weight, with Asians lowest and Black or multiracial individuals often leading.

Systolic BP is lowest among Asians from ages 29 to 45, while Black individuals show the highest values from ages 37 to 67. Interestingly, among the elderly (around age 80), Asians show a spike and have the highest systolic BP. Diastolic BP tends to be lowest among Hispanics and highest among Black individuals across most age groups.

Cholesterol levels appear fairly similar across ethnicities, with each group leading slightly at different age points.

In terms of diet, Asians typically have the lowest calorie intake. Mexican Americans consume the most in late teens to early 30s, while Whites lead from ages 54 to 80. Protein intake is lowest among Black individuals and highest among Mexican Americans up to age 45. After that, multiracial individuals and then Whites take the lead, though by age 80, Asians surprisingly have the highest protein intake.

Fat intake is lowest for Asians across all age groups. Black individuals lead in early adulthood, multiracial individuals peak in their mid-30s, and Whites have the highest fat intake from midlife onward.

## Interactive Data Table
At last, I build an interactive data table using Panel and Bokeh that allows filtering by gender and race/ethnicity. I start by creating two selection widgets — one for Gender and another for RaceEthnicity — with options including "All" to show the unfiltered data.

Next, I define a function that reacts to changes in these widgets. It filters the original DataFrame based on the selected values, converts the result into a `ColumnDataSource`, and creates a dynamic Bokeh `DataTable` using the filtered data.
"""

# Binning drop
df = df.drop('AgeBin', axis=1)

# Define the gender and race widgets
gender_select = pn.widgets.Select(name='Gender', options=['All'] + sorted(df['Gender'].unique()))
race_select = pn.widgets.Select(name='RaceEthnicity', options=['All'] + sorted(df['RaceEthnicity'].unique()))

@pn.depends(gender_select, race_select)
def filtered_table(gender, race):
    # Filter the dataframe based on the selected gender, race
    dff = df.copy()

    # Apply the filters
    if gender != "All":
        dff = dff[dff['Gender'] == gender]
    if race != "All":
        dff = dff[dff['RaceEthnicity'] == race]

    # Create a ColumnDataSource from the filtered dataframe
    source = ColumnDataSource(dff)

    # Create table columns dynamically based on the dataframe
    columns = [TableColumn(field=c, title=c) for c in dff.columns]
    table = DataTable(source=source, columns=columns, width=800, height=300)

    return table

# Layout
layout = pn.Column(
    pn.pane.Markdown("### Interactive Data Table"),
    pn.Row(gender_select, race_select),
    filtered_table
)

layout.servable()

"""This interactive table allows me to quickly explore and compare subsets of the dataset based on gender and race/ethnicity, helping uncover demographic patterns and trends. For example, by filtering to just females or a specific ethnic group like "Asian," I can observe variations in health metrics such as BMI, blood pressure, or dietary intake across different populations.
This table makes it easier to validate observations from previous visualizations and ensures no group-level insights are overlooked.

## Ethical and Data Privacy Considerations

While working with NHANES data, I handled sensitive personal health information such as BMI, blood pressure, and dietary intake. Although the data was publicly available and de-identified, merging multiple datasets using unique participant IDs (like SEQN) raised potential privacy concerns, particularly due to the risk of re-identification through combinations of demographic variables such as age, gender, and race/ethnicity.

Ethically, I ensured that the data was used responsibly and without introducing bias. Care was taken to avoid reinforcing stereotypes or drawing stigmatizing conclusions about any particular group during subgroup analysis or visualization. I maintained transparency about the limitations of the dataset and the interpretations made. Furthermore, while building interactive dashboards and visual tools, I ensured that data anonymity was preserved and results were communicated accurately.

## Conclusion
This analysis provided a comprehensive look into key health indicators using data from the NHANES study. By integrating multiple datasets and leveraging interactive visualizations, I was able to explore how metrics such as BMI, cholesterol, and blood pressure vary across different age groups, genders, and ethnicities. The interactivity allowed for flexible filtering and deeper insights that would be harder to uncover with static plots. Patterns such as higher BMI among females, distinct dietary trends across ethnic groups, and blood pressure shifts with age highlighted how health outcomes differ across demographic segments.

Future extensions of this analysis could involve incorporating additional NHANES modules like lab test results, physical activity data, or socioeconomic indicators. Machine learning models could also be applied to predict health outcomes or detect high-risk subpopulations.
"""